<strong><big>vmwhere 1,2</big></strong><br>
1はvmwhere移植して、読み取られた文字をカウントして、<br>
カウント増えたら確定させていったらいい。<br><br>
2は同じ処理をしているところが2個あるので、この2個を解く。<br>
1個めの処理(実際はその前に0A 00がある,これを46回している)
```
08 <-08は入力された1文字を取得する
11
0A FF
10 09
10 08
0A 00
label_128:10 02
0F
0A FF
05
0C label_141 <-0Cはもしスタックの値が0ならジャンプ
0E
0D label_145 <-0Dは無条件ジャンプ
label_141:0E
0D label_167
label_145:10 02
10 02
0C label_159
0E
0A 01
01
0D label_160
label_159:0E
label_160:0F
0F
01
01
0D label_128
label_167:0E
```
2個めの処理(規則的に変わっているのでforを使ってる)
```
byte[] data={0xc6, 0x8b, 0xd9, 0xcf, 0x63, 0x60, 0xd8, 0x7b, 0xd8, 0x60, 0xf6, 0xd3, 0x7b, 0xf6, 0xd8, 0xc1, 0xcf, 0xd0, 0xf6, 0x72, 0x63, 0x75, 0xbe, 0xf6, 0x7f, 0xd8, 0x63, 0xe7, 0x6d, 0xf6, 0x63, 0xcf, 0xf6, 0xd8, 0xf6, 0xd8, 0x63, 0xe7, 0x6d, 0xb4, 0x88, 0x72, 0x70, 0x75, 0xb8, 0x75}
for(int i=0;i<46;i++){
    put(data[i]);
    xor();
    swap(0x2f-1-i);
    swap(0x2f-i);
    or();
    swap(0x2f-1-i);
    swap(0x2f-2-i);
}
```
最終的に0になればいいので上のdataをxorしたらすべて0になればよい(->同値となればよい)<br>
つまり移植したやつで1個めの処理を各アルファベット,記号に対して実行させて<br>
対応する値を置き換える(注意としてdataは逆の順です)<br>
ちなみに移植したのバグで2のコードが動かないので無理だった<br>
(まあ、vmwhere 1が動くのとのと完全に動かなくてもスタックとかがわかればいいから...)<br>
1個めのコードからある文字に対して出力されるのを調べる(下のコード)<br>
(programの一部コピーだけど終了処理のため00を追加する,<br>
08はすでにスタックにデータ突っ込んでるからいらない)
```
11 0A FF 10 09 10 08 0A 00 10 02 0F 0A FF 05 0C
00 04 0E 0D 00 04 0E 0D 00 16 10 02 10 02 0C 00
07 0E 0A 01 01 0D 00 01 0E 0F 0F 01 01 0D FF D9
0E 00
```
Solver.javaはコード実行するのと結果から、フラグを取得するやつ<br>
Reader.javaは1個めのコードみたいにちょっとだけ読みやすくするやつです<br>
uiuctf{b4sZ_Z_Xs_b4sZd_just_lXkZ_vm_rZvZrsXng}もCorrectでるけど(g->@,n->空白もある)<br>
<strong>今回のフラグには大文字のアルファベットは含まないと運営が言った</strong>ので<br>
uiuctf{b4s3_3_1s_b4s3d_just_l1k3_vm_r3v3rs1ng}となる<br><br>
こんなことになった理由としては1,Xを例に挙げると<br>
1は3cf<br>
Xは9cf<br>
だけど比較しているのはcfの部分だけ(それより上は消される)だから両方同値と考えられてしまう